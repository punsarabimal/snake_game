<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Snake — Responsive</title>
<style>
  :root{
    --ui-bg: rgba(0,0,0,0.6);
    --btn-bg: rgba(255,255,255,0.06);
    --accent: #4caf50;
    --danger: #e53935;
    --glass: rgba(255,255,255,0.06);
    --control-size: 64px;
  }

  html,body{
    height:100%;
    margin:0;
    background:#0b0b0b;
    color:#eee;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    -webkit-user-select:none;
    user-select:none;
    touch-action:none;
  }

  canvas{
    display:block;
    width:100vw;
    height:100vh;
    background:linear-gradient(180deg,#07121a 0%, #06121a 100%);
    image-rendering: pixelated;
  }

  /* Top UI: speed control */
  #topbar{
    position:fixed;
    left:12px;
    top:12px;
    z-index:30;
    display:flex;
    align-items:center;
    gap:10px;
    padding:8px 10px;
    border-radius:12px;
    background:var(--ui-bg);
    backdrop-filter: blur(6px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    font-size:14px;
  }
  #speed { width:160px; }
  #speedVal { min-width:32px; text-align:center; display:inline-block; }

  /* Overlay for paused / game over */
  #overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:50;
    pointer-events:none;
    font-size:28px;
    color:#fff;
    text-shadow:0 2px 8px rgba(0,0,0,0.7);
  }
  #overlay .card{
    pointer-events:auto;
    background:linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.35));
    padding:18px 22px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.05);
    text-align:center;
  }
  #overlay .small { font-size:14px; opacity:0.85; margin-top:8px; }

  /* Mobile controls (shown only on touch) */
  #mobile-controls{
    position:fixed;
    bottom:16px;
    left:50%;
    transform:translateX(-50%);
    z-index:40;
    display:flex;
    align-items:center;
    gap:12px;
    pointer-events:auto;
  }
  .pad{
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    grid-template-rows: auto 1fr auto;
    gap:8px;
    align-items:center;
    justify-items:center;
    padding:8px;
    background:var(--glass);
    border-radius:14px;
    box-shadow:0 8px 24px rgba(0,0,0,0.6);
    border:1px solid rgba(255,255,255,0.04);
  }
  .arrow, #btn-pause, #btn-restart{
    width:var(--control-size);
    height:var(--control-size);
    font-size:28px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:10px;
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:#fff;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .arrow:active, #btn-pause:active, #btn-restart:active {
    transform: translateY(1px);
    filter:brightness(1.05);
  }
  .small-btn{
    width:48px;
    height:48px;
    font-size:20px;
  }
  /* Hide mobile controls by default; will enable with JS on touch devices */
  .hidden { display:none !important; }

  /* Score at top-right */
  #score{
    position:fixed;
    right:12px;
    top:12px;
    z-index:30;
    padding:8px 10px;
    border-radius:12px;
    background:var(--ui-bg);
    backdrop-filter: blur(6px);
    font-size:14px;
  }

  /* Responsive tweaks */
  @media (min-width:900px){
    :root { --control-size:56px; }
  }

</style>
</head>
<body>
  <canvas id="game" tabindex="0"></canvas>

  <div id="topbar">
    <label for="speed">Speed</label>
    <input id="speed" type="range" min="1" max="20" value="8" />
    <span id="speedVal">8</span> <small style="opacity:.8;margin-left:6px">moves/s</small>
  </div>

  <div id="score">Score: <span id="scoreVal">0</span></div>

  <div id="overlay" class="hidden" aria-hidden="true">
    <div class="card">
      <div id="overlayMsg">Paused</div>
      <div class="small" id="overlayHint">Esc to resume • Enter to restart</div>
    </div>
  </div>

  <!-- mobile controls -->
  <div id="mobile-controls" class="hidden" aria-hidden="true">
    <div class="pad" id="pad">
      <div></div>
      <button class="arrow" data-dir="0,-1" aria-label="Up">▲</button>
      <div></div>

      <button class="arrow" data-dir="-1,0" aria-label="Left">◀</button>
      <button id="btn-pause" class="small-btn" aria-label="Pause">⏯</button>
      <button class="arrow" data-dir="1,0" aria-label="Right">▶</button>

      <div></div>
      <button class="arrow" data-dir="0,1" aria-label="Down">▼</button>
      <div></div>
    </div>
    <button id="btn-restart" aria-label="Restart">⟲</button>
  </div>

<script>
/* ======= Snake Game — readable implementation ======= */

(function(){
  // DOM
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', { alpha: false });
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const scoreEl = document.getElementById('scoreVal');
  const overlay = document.getElementById('overlay');
  const overlayMsg = document.getElementById('overlayMsg');
  const overlayHint = document.getElementById('overlayHint');
  const mobileControls = document.getElementById('mobile-controls');
  const pad = document.getElementById('pad');
  const btnPause = document.getElementById('btn-pause');
  const btnRestart = document.getElementById('btn-restart');

  // device detection
  const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

  // pixel ratio for crisp canvas
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Game configuration
  const MIN_CELL = 12; // px
  const TARGET_COLS = 30; // target columns to try to achieve
  let cell = 20;
  let cols = 30;
  let rows = 20;

  // Game state
  let snake = [];
  let dir = { x: 1, y: 0 }; // current direction
  let nextDir = { x: 1, y: 0 }; // direction set by user (applied on next move)
  let food = null;
  let score = 0;
  let paused = false;
  let gameOver = false;

  // Timing
  let movesPerSecond = parseInt(speedInput.value, 10) || 8;
  let moveInterval = 1000 / movesPerSecond;
  let lastTime = performance.now();
  let acc = 0;
  let rafId = null;

  // initial setup and event hooks
  function init(){
    resize();
    resetGame();
    bindEvents();
    updateSpeedDisplay();
    showMobileIfNeeded();
    // start loop
    lastTime = performance.now();
    acc = 0;
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  // Responsive canvas sizing — fills viewport and sets logical grid
  function resize(){
    const w = window.innerWidth;
    const h = window.innerHeight;

    // choose an appropriate cell size so grid is reasonable on both phone & desktop
    cell = Math.max(MIN_CELL, Math.floor(Math.min(w / TARGET_COLS, h / Math.max(12, Math.floor(TARGET_COLS * 0.6)))));
    cols = Math.max(10, Math.floor(w / cell));
    rows = Math.max(10, Math.floor(h / cell));

    // set canvas physical size for crispness
    cvs.style.width = w + 'px';
    cvs.style.height = h + 'px';
    cvs.width = Math.round(w * DPR);
    cvs.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to CSS pixels
    // clear and redraw after resizing
    draw();
  }

  // reset game state
  function resetGame(){
    // start snake roughly centered and horizontal
    const startLen = Math.max(4, Math.floor(Math.min(cols, rows) / 6));
    const sx = Math.floor(cols / 2);
    const sy = Math.floor(rows / 2);
    snake = [];
    for(let i = startLen - 1; i >= 0; i--){
      snake.push({ x: sx - i, y: sy });
    }
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };
    placeFood();
    score = 0;
    gameOver = false;
    paused = false;
    updateScore();
    hideOverlay();
  }

  function placeFood(){
    // find a cell not occupied by snake
    if(cols <= 1 || rows <= 1) { food = {x:0,y:0}; return; }
    let tries = 0;
    while(true){
      const fx = Math.floor(Math.random() * cols);
      const fy = Math.floor(Math.random() * rows);
      let hit = false;
      for(const s of snake) {
        if(s.x === fx && s.y === fy){ hit = true; break; }
      }
      if(!hit){ food = { x: fx, y: fy }; return; }
      if(++tries > 500){ // fallback
        food = { x: Math.floor(cols/3), y: Math.floor(rows/3) };
        return;
      }
    }
  }

  // change requested direction (prevents 180-degree reversal)
  function setDirection(nx, ny){
    // ignore reversing direction immediately (if length > 1)
    if(snake.length > 1 && nx === -dir.x && ny === -dir.y) return;
    nextDir = { x: nx, y: ny };
  }

  // advance snake one step
  function step(){
    if(gameOver || paused) return;
    // apply nextDir
    dir = nextDir;
    const head = snake[snake.length - 1];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    // collision with walls => game over
    if(nx < 0 || nx >= cols || ny < 0 || ny >= rows){
      endGame();
      return;
    }
    // collision with self
    for(let i = 0; i < snake.length; i++){
      const s = snake[i];
      if(s.x === nx && s.y === ny){
        endGame();
        return;
      }
    }

    // push new head
    snake.push({ x: nx, y: ny });

    // eat food?
    if(food && nx === food.x && ny === food.y){
      score += 1;
      updateScore();
      placeFood();
    } else {
      // remove tail
      snake.shift();
    }
  }

  function updateScore(){ scoreEl.textContent = String(score); }

  function endGame(){
    gameOver = true;
    showOverlay('Game Over', 'Enter to restart • Esc to continue');
  }

  // overlay controls
  function showOverlay(msg = 'Paused', hint='Esc to resume • Enter to restart'){
    overlayMsg.textContent = msg;
    overlayHint.textContent = hint;
    overlay.classList.remove('hidden');
    overlay.setAttribute('aria-hidden', 'false');
  }
  function hideOverlay(){
    overlay.classList.add('hidden');
    overlay.setAttribute('aria-hidden', 'true');
  }

  function togglePause(){
    if(gameOver){
      // don't toggle pause on game over — overlay shows gameover
      return;
    }
    paused = !paused;
    if(paused) showOverlay('Paused', 'Esc to resume • Enter to restart');
    else hideOverlay();
  }

  // restart
  function restart(){
    resetGame();
  }

  // main loop: decouple logic ticks from rendering so speed slider works smoothly
  function loop(now){
    rafId = requestAnimationFrame(loop);
    const dt = now - lastTime;
    lastTime = now;
    acc += dt;
    moveInterval = 1000 / movesPerSecond;
    // perform moves while accumulator allows (in case of low framerate)
    while(acc >= moveInterval){
      acc -= moveInterval;
      step();
    }
    draw();
  }

  // drawing
  function draw(){
    const w = cvs.clientWidth;
    const h = cvs.clientHeight;
    // fill background
    ctx.clearRect(0,0,w,h);
    // compute offsets to align grid to top-left and maintain integer cell sizes
    // we'll compute cell size based on current chosen cell
    const cx = cell;
    // draw food
    if(food){
      ctx.fillStyle = '#ff5252';
      roundRect(ctx, food.x * cx + 2, food.y * cx + 2, cx - 4, cx - 4, Math.max(3, cx/6));
      ctx.fill();
    }
    // draw snake
    // nice gradient head color
    const head = snake[snake.length - 1];
    for(let i = 0; i < snake.length; i++){
      const s = snake[i];
      const age = i / snake.length;
      // body color: darker -> lighter gradient
      ctx.fillStyle = i === snake.length - 1 ? '#a6ff97' : `rgba(${Math.floor(60 + 120*age)}, ${Math.floor(180 - 60*age)}, ${Math.floor(80 + 80*(1-age))}, 1)`;
      roundRect(ctx, s.x * cx + 1, s.y * cx + 1, cx - 2, cx - 2, Math.max(2, cx/6));
      ctx.fill();
    }

    // optionally draw grid (disabled for performance)
    // draw walls border
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 2;
    ctx.strokeRect(0.5,0.5, cols * cx - 1, rows * cx - 1);
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // UI bindings
  function updateSpeedDisplay(){
    speedVal.textContent = String(movesPerSecond);
  }
  speedInput.addEventListener('input', e => {
    const v = parseInt(e.target.value, 10) || 8;
    movesPerSecond = v;
    updateSpeedDisplay();
  });

  // keyboard controls
  function onKeyDown(e){
    // prevent arrow keys from scrolling
    const arrowKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '];
    if(arrowKeys.includes(e.key)) e.preventDefault();

    if(e.key === 'ArrowUp') setDirection(0, -1);
    else if(e.key === 'ArrowDown') setDirection(0, 1);
    else if(e.key === 'ArrowLeft') setDirection(-1, 0);
    else if(e.key === 'ArrowRight') setDirection(1, 0);
    else if(e.key === 'Escape') togglePause();
    else if(e.key === 'Enter') {
      if(gameOver) restart();
      else restart(); // also restart mid-game
    }
  }

  // mobile (touch) controls
  function showMobileIfNeeded(){
    if(isTouch || window.innerWidth < 900){
      mobileControls.classList.remove('hidden');
      mobileControls.setAttribute('aria-hidden', 'false');
      // attach button handlers
      const arrows = pad.querySelectorAll('.arrow');
      arrows.forEach(b => {
        // support touch and mouse
        b.addEventListener('touchstart', onPadPress, {passive:false});
        b.addEventListener('mousedown', onPadPress);
      });
      btnPause.addEventListener('touchstart', onPausePress, {passive:false});
      btnPause.addEventListener('mousedown', onPausePress);
      btnRestart.addEventListener('touchstart', onRestartPress, {passive:false});
      btnRestart.addEventListener('mousedown', onRestartPress);
      // prevent accidental touch scrolls over the pad
      pad.addEventListener('touchmove', e => e.preventDefault(), {passive:false});
    } else {
      mobileControls.classList.add('hidden');
      mobileControls.setAttribute('aria-hidden', 'true');
    }
  }

  function onPadPress(ev){
    if(ev) ev.preventDefault();
    const dirAttr = this ? this.getAttribute('data-dir') : ev.currentTarget.getAttribute('data-dir');
    if(!dirAttr) return;
    const parts = dirAttr.split(',').map(n=>parseInt(n,10));
    setDirection(parts[0], parts[1]);
  }
  function onPausePress(ev){ if(ev) ev.preventDefault(); togglePause(); }
  function onRestartPress(ev){ if(ev) ev.preventDefault(); restart(); }

  // global bindings
  function bindEvents(){
    window.addEventListener('resize', debounce(resize, 120));
    window.addEventListener('keydown', onKeyDown, {passive:false});
    // focus canvas to catch keyboard on desktop
    cvs.addEventListener('click', ()=> cvs.focus());
    // ensure canvas can get keyboard focus
    cvs.setAttribute('tabindex','0');
  }

  // util: debounce
  function debounce(fn, t){
    let to = null;
    return function(...a){
      clearTimeout(to);
      to = setTimeout(()=> fn.apply(this,a), t);
    };
  }

  // start
  init();

  // Expose a couple functions to console for quick testing (optional, non-intrusive)
  window.SNAKE = {
    restart: restart,
    pause: ()=> { paused = true; showOverlay('Paused','Esc to resume • Enter to restart'); },
    resume: ()=> { paused = false; hideOverlay(); },
    setSpeed: s => { movesPerSecond = Math.max(1, Math.min(60, +s)); speedInput.value = movesPerSecond; updateSpeedDisplay(); }
  };

})();
</script>
</body>
  </html>
