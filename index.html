<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Responsive Snake Game</title>
<style>
  :root{
    --bg:#0f0f10;
    --panel:#111216;
    --accent:#0f9d57;
    --muted:#9aa0a6;
    --btn-bg:#131518;
    --btn-border: rgba(255,255,255,0.08);
  }
  html,body{
    height:100%;
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:var(--bg);
    color:#fff;
    -webkit-tap-highlight-color: transparent;
  }

  .wrap{
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:18px 12px;
    box-sizing:border-box;
  }
  header{
    text-align:center;
    margin-bottom:8px;
  }
  h1{ margin:4px 0 2px; font-size:24px; }
  .subtitle{ color:var(--muted); font-size:13px; margin:0 0 6px; }

  /* canvas container */
  .board-wrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    width:100%;
    max-width:920px;
  }
  .canvas-area{
    background: #061009;
    border: 2px solid rgba(15,157,87,0.12);
    padding:8px;
    box-sizing:border-box;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  canvas{
    display:block;
    background:#020202;
    border-radius:4px;
    touch-action: none; /* prevent scrolling when dragging on mobile */
  }

  /* info row */
  .info-row{
    width:100%;
    max-width:920px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    margin-top:8px;
    font-size:14px;
    color:var(--muted);
  }

  /* controls (mobile) */
  .mobile-controls{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
    margin-top:12px;
    user-select:none;
  }
  .btn-row{
    display:flex;
    gap:10px;
  }
  .ctl-btn{
    background:var(--btn-bg);
    border:1px solid var(--btn-border);
    padding:10px 12px;
    border-radius:8px;
    min-width:48px;
    min-height:44px;
    display:inline-flex;
    justify-content:center;
    align-items:center;
    font-size:18px;
    color:#fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.35);
  }
  .ctl-btn:active{ transform:translateY(1px); }
  .wide{ min-width:110px; display:flex; gap:8px; justify-content:center; align-items:center; }

  /* speed control */
  .speed-wrap{ display:flex; gap:10px; align-items:center; color:var(--muted); }
  input[type=range]{ accent-color: var(--accent); }

  /* desktop instructions */
  .kbd-instructions{ color:var(--muted); font-size:13px; }

  /* overlay messages */
  .overlay{
    position:fixed;
    left:0; right:0; top:0; bottom:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(1,1,1,0.35), rgba(1,1,1,0.6));
    z-index:40;
    pointer-events:none;
    opacity:0;
    transition:opacity .18s ease;
  }
  .overlay.show{
    pointer-events:auto;
    opacity:1;
  }
  .overlay .panel{
    background:var(--panel);
    padding:20px 22px;
    border-radius:12px;
    text-align:center;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    min-width:220px;
    color:#fff;
  }
  .overlay h2{ margin:0 0 6px; font-size:18px; }
  .overlay p{ margin:0; color:var(--muted); font-size:13px; }

  /* small screen -> show mobile controls */
  @media (max-width: 767px){
    .mobile-controls{ display:block; }
    .kbd-instructions{ display:none; }
  }
  /* large screens -> hide mobile controls */
  @media (min-width: 768px){
    .mobile-controls{ display:none; }
    .kbd-instructions{ display:block; }
  }

  footer{ margin-top:16px; color:var(--muted); font-size:12px; }

  /* pretty buttons */
  .btn-compact{
    background:linear-gradient(180deg,#0f9d57,#0c7f45);
    color:#fff;
    padding:8px 12px;
    border-radius:8px;
    border:none;
    cursor:pointer;
    font-weight:600;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Snake Game</h1>
    <div class="subtitle">Works on desktop & mobile ‚Äî arrow keys (desktop) or on-screen buttons (mobile). Enter = Restart, Esc = Pause/Resume</div>
  </header>

  <div class="board-wrap">
    <div class="canvas-area">
      <canvas id="gameCanvas" aria-label="Snake game canvas"></canvas>
    </div>

    <div class="info-row" id="infoRow">
      <div>Score: <span id="score">0</span></div>
      <div class="speed-wrap">
        <label for="speedRange">Speed</label>
        <input id="speedRange" type="range" min="60" max="320" step="10" value="150">
        <small id="speedLabel">Normal</small>
      </div>
      <div class="kbd-instructions">
        Desktop: Arrow keys to move ‚Ä¢ Enter restart ‚Ä¢ Esc pause/resume
      </div>
    </div>

    <!-- Mobile controls (only visible on small screens via CSS) -->
    <div class="mobile-controls" aria-hidden="false">
      <div class="btn-row">
        <div class="ctl-btn" data-dir="up" title="Up">‚¨ÜÔ∏è</div>
      </div>
      <div class="btn-row">
        <div class="ctl-btn" data-dir="left" title="Left">‚¨ÖÔ∏è</div>
        <div class="ctl-btn" data-dir="down" title="Down">‚¨áÔ∏è</div>
        <div class="ctl-btn" data-dir="right" title="Right">‚û°Ô∏è</div>
      </div>

      <div class="btn-row">
        <div class="ctl-btn wide" id="restartBtn">üîÑ Restart</div>
        <div class="ctl-btn wide" id="pauseBtn">‚èØ Pause</div>
      </div>
    </div>
  </div>

  <footer>
    Tip: On mobile, use on-screen arrows. On desktop use keyboard arrows.
  </footer>
</div>

<!-- lightweight script -->
<script>
(() => {
  // === DOM ===
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const mobileBtns = document.querySelectorAll('.ctl-btn[data-dir]');

  // === state ===
  let TILE = 20;             // px (CSS pixels) - will be recalculated on resize
  let COLS = 20, ROWS = 20;  // grid size - recalculated based on screen size
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  let snake = [];            // array of {x,y} (grid coordinates), head at index 0
  let dir = {x:0,y:0};       // current movement direction
  let nextDir = null;        // queued direction (applied on next tick)
  let food = {x:0,y:0};
  let score = 0;
  let running = false;       // game has been started at least once
  let paused = true;         // paused state (start paused until first direction input)
  let tickId = null;
  let speed = parseInt(speedRange.value,10); // milliseconds per tick

  // === helpers ===
  function setSpeedLabel(v){
    if(v < 100) speedLabel.textContent = 'Very Fast';
    else if (v < 140) speedLabel.textContent = 'Fast';
    else if (v < 200) speedLabel.textContent = 'Normal';
    else if (v < 260) speedLabel.textContent = 'Slow';
    else speedLabel.textContent = 'Very Slow';
  }
  setSpeedLabel(speed);

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // responsive sizing: compute COLS/ROWS and TILE size based on viewport,
  // then set canvas CSS size and internal pixel size adjusted for DPR.
  function resizeAndRecreateCanvas(){
    // space available for canvas: keep it square
    const margin = 32; // some margin on sides
    const availW = Math.min(window.innerWidth - margin, 920);
    const availH = Math.max(window.innerHeight - 220, 260);

    // pick a base target size (CSS pixels)
    const target = Math.floor(Math.min(availW, availH) * 0.92);

    // choose grid resolution based on target size
    if(target >= 800){ COLS = ROWS = 30; }
    else if (target >= 600){ COLS = ROWS = 26; }
    else if (target >= 420){ COLS = ROWS = 22; }
    else { COLS = ROWS = 20; }

    TILE = Math.floor(target / COLS);
    if(TILE < 12) TILE = 12;

    // final CSS pixel size for canvas
    const cssSize = TILE * COLS;

    // set CSS size
    canvas.style.width = cssSize + 'px';
    canvas.style.height = cssSize + 'px';

    // set actual drawing buffer for high-DPI
    canvas.width = Math.round(cssSize * dpr);
    canvas.height = Math.round(cssSize * dpr);

    // map drawing operations back to CSS pixels
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // if game running, restart so grid matches new size
    // we keep speed and paused state; restarting clears interval safely.
    if(running) {
      restart(true); // keep paused state
    } else {
      // initial reset for first load
      resetState();
      draw(); // draw initial single-tile snake/food
    }
  }

  // Generate random free cell for food
  function randomFoodPosition(){
    // build a set of occupied positions to avoid placing on snake
    const occupied = new Set(snake.map(p => `${p.x},${p.y}`));
    let attempts = 0;
    while(true){
      const x = Math.floor(Math.random() * COLS);
      const y = Math.floor(Math.random() * ROWS);
      if(!occupied.has(`${x},${y}`)) return {x,y};
      if(++attempts > 1000) return {x: 0, y:0}; // fallback
    }
  }

  function resetState(){
    // Place snake in center, length 3
    const cx = Math.floor(COLS/2);
    const cy = Math.floor(ROWS/2);
    snake = [
      {x: cx, y: cy},
      {x: cx-1, y: cy},
      {x: cx-2, y: cy}
    ];
    dir = {x: 0, y: 0};   // stationary until user presses a direction
    nextDir = null;
    food = randomFoodPosition();
    score = 0;
    updateScore();
    paused = true;
    running = false;
    clearTick();
  }

  function restart(keepPaused=false){
    clearTick();
    resetBoardForRestart();
    running = true;
    if(!keepPaused){
      paused = true; // will unpause when user presses first direction
    }
    // If we want to start immediately (if direction already supplied), don't auto-unpause.
    draw();
  }

  function resetBoardForRestart(){
    const cx = Math.floor(COLS/2);
    const cy = Math.floor(ROWS/2);
    snake = [
      {x: cx, y: cy},
      {x: cx-1, y: cy},
      {x: cx-2, y: cy}
    ];
    dir = {x: 0, y: 0};
    nextDir = null;
    food = randomFoodPosition();
    score = 0;
    updateScore();
    clearTick();
  }

  // Start the tick loop with current speed if not paused
  function startTickLoop(){
    clearTick();
    if(paused) return;
    tickId = setInterval(tick, speed);
  }
  function clearTick(){
    if(tickId !== null){ clearInterval(tickId); tickId = null; }
  }

  // Apply a direction change (dirName is 'up'|'down'|'left'|'right')
  function changeDirectionByName(dirName){
    const map = {
      up: {x:0,y:-1},
      down: {x:0,y:1},
      left: {x:-1,y:0},
      right: {x:1,y:0}
    };
    const nd = map[dirName];
    if(!nd) return;
    // Prevent reversing direction 180¬∞
    if(dir.x === -nd.x && dir.y === -nd.y) return;
    // If currently stationary (dir 0,0) and paused, we'll unpause and use this as initial dir
    if(dir.x === 0 && dir.y === 0 && paused){
      dir = nd;
      nextDir = null;
      paused = false;
      running = true;
      startTickLoop();
      draw();
      return;
    }
    // Queue nextDir to be applied on next tick; prevents 180¬∞ reversal within same tick
    nextDir = nd;
  }

  function updateScore(){
    scoreEl.textContent = score;
  }

  // Single tick: move snake one cell
  function tick(){
    if(paused) return; // safety

    // apply queued dir (if any)
    if(nextDir){
      // ensure not reversing against current head movement
      if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
        dir = nextDir;
      }
      nextDir = null;
    }

    // if still stationary (user hasn't given direction), do nothing
    if(dir.x === 0 && dir.y === 0) return;

    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    // wall collision
    if(newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS){
      gameOver();
      return;
    }

    // self collision
    for(let i=0;i<snake.length;i++){
      const p = snake[i];
      if(p.x === newHead.x && p.y === newHead.y){
        gameOver();
        return;
      }
    }

    // eat food?
    const ate = (newHead.x === food.x && newHead.y === food.y);
    // push head
    snake.unshift(newHead);
    if(ate){
      score++;
      updateScore();
      // speed-up small amount every few points (optional)
      // generate new food
      food = randomFoodPosition();
    } else {
      // remove tail
      snake.pop();
    }

    // draw after moving
    draw();
  }

  function gameOver(){
    paused = true;
    clearTick();
    // show simple alert style overlay using built-in confirm to keep code simple
    // But we'll show a custom overlay-like dialog: use window.confirm to restart?
    // Use native confirm to avoid adding UI overlay complexity:
    setTimeout(()=>{ // slight timeout so last frame paints
      const restartNow = confirm('Game Over ‚Äî Score: ' + score + '\nRestart game?');
      if(restartNow){
        restart(false);
      } else {
        // keep paused
      }
    }, 50);
  }

  // Drawing
  function draw(){
    // CSS pixel canvas size
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    // clear
    ctx.clearRect(0,0, cssW, cssH);

    // background
    ctx.fillStyle = '#020202';
    ctx.fillRect(0,0,cssW,cssH);

    // border (inside)
    ctx.strokeStyle = 'rgba(15,157,87,0.12)';
    ctx.lineWidth = Math.max(1, TILE * 0.06);
    ctx.strokeRect(0.5, 0.5, cssW-1, cssH-1);

    // draw food
    if(food){
      drawCell(food.x, food.y, '#e23b3b'); // red food
    }

    // draw snake
    for(let i=snake.length-1;i>=0;i--){
      const p = snake[i];
      if(i===0){
        drawCell(p.x, p.y, '#0fd57f'); // head
        // small eye depending on dir
        drawHeadEye(p, dir);
      } else {
        drawCell(p.x, p.y, (i%2===0) ? '#077a44' : '#0a8c56'); // body gradient
      }
    }

    // Score text (top-left inside canvas)
    ctx.fillStyle = '#d9dfe4';
    ctx.font = Math.max(12, TILE * 0.6) + 'px system-ui, Arial';
    ctx.textBaseline = 'top';
    ctx.fillText('Score: ' + score, Math.max(6, TILE*0.25), Math.max(6, TILE*0.25));
  }

  function drawCell(cx, cy, color){
    const x = cx * TILE;
    const y = cy * TILE;
    const pad = Math.max(1, Math.floor(TILE * 0.08));
    const w = TILE - pad*2;
    const h = TILE - pad*2;
    // rounded rect
    ctx.fillStyle = color;
    const r = Math.max(2, Math.floor(TILE * 0.12));
    roundRect(ctx, x+pad, y+pad, w, h, r, true, false);
  }

  function drawHeadEye(head, dir){
    // small eye circle on head so it's easier to see facing
    const cx = head.x * TILE;
    const cy = head.y * TILE;
    const centerX = cx + TILE/2;
    const centerY = cy + TILE/2;
    const eyeOffset = TILE * 0.22;
    let ex = centerX, ey = centerY;
    if(dir.x === 1) ex += eyeOffset;
    else if(dir.x === -1) ex -= eyeOffset;
    else if(dir.y === 1) ey += eyeOffset;
    else if(dir.y === -1) ey -= eyeOffset;

    ctx.beginPath();
    ctx.fillStyle = '#05321e';
    ctx.arc(ex, ey, Math.max(1.5, TILE*0.08), 0, Math.PI*2);
    ctx.fill();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'undefined') r = 5;
    if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x + r.bl, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // === Input handling ===
  function handleKeyDown(e){
    // handle only a subset
    const k = e.key;
    if(k === 'ArrowUp' || k === 'w' || k === 'W'){
      e.preventDefault(); changeDirectionByName('up');
    } else if(k === 'ArrowDown' || k === 's' || k === 'S'){
      e.preventDefault(); changeDirectionByName('down');
    } else if(k === 'ArrowLeft' || k === 'a' || k === 'A'){
      e.preventDefault(); changeDirectionByName('left');
    } else if(k === 'ArrowRight' || k === 'd' || k === 'D'){
      e.preventDefault(); changeDirectionByName('right');
    } else if(k === 'Enter'){
      e.preventDefault(); restart(false);
    } else if(k === 'Escape'){
      e.preventDefault(); togglePause();
    }
  }

  function togglePause(){
    if(!running){
      // nothing to pause, start a fresh game
      restart(false);
      return;
    }
    paused = !paused;
    if(paused){
      clearTick();
      pauseBtn.textContent = '‚ñ∂ Resume';
    } else {
      startTickLoop();
      pauseBtn.textContent = '‚èØ Pause';
    }
  }

  // click / touch bindings for mobile buttons
  mobileBtns.forEach(btn=>{
    const dirName = btn.dataset.dir;
    // support both pointer events and click for reliability
    btn.addEventListener('pointerdown', (ev) => { ev.preventDefault(); changeDirectionByName(dirName); });
    btn.addEventListener('click', (ev) => { ev.preventDefault(); changeDirectionByName(dirName); });
  });

  // restart & pause UI
  restartBtn.addEventListener('click', (e)=>{ e.preventDefault(); restart(false); });
  pauseBtn.addEventListener('click', (e)=>{ e.preventDefault(); togglePause(); });

  // speed change
  speedRange.addEventListener('input', (e) => {
    const v = parseInt(e.target.value,10);
    speed = clamp(v, 40, 1000);
    setSpeedLabel(speed);
    // if currently running and unpaused, re-create interval with new speed
    if(running && !paused){
      startTickLoop();
    }
  });

  // keyboard listeners
  window.addEventListener('keydown', handleKeyDown);

  // resize handling
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> {
      // recompute sizes and restart to keep cells integer
      dpr = Math.max(1, window.devicePixelRatio || 1);
      resizeAndRecreateCanvas();
    }, 120);
  });

  // start initial canvas sizing and initial state
  resizeAndRecreateCanvas();
  resetState();
  draw();

  // Expose small API to console (optional)
  window.SnakeGame = {
    restart: () => restart(false),
    togglePause: () => togglePause(),
    setSpeed: (ms) => { speed = ms; speedRange.value = ms; setSpeedLabel(ms); if(running && !paused) startTickLoop(); }
  };

})();
</script>
</body>
</html>const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let box = 20;
let snake = [{x: 9 * box, y: 9 * box}];
let direction = null;
let food = randomFood();
let score = 0;
let game;
let speed = 150;
let isPaused = false;

document.getElementById("speedSlider").oninput = function() {
    speed = this.value;
    restartGame();
};

document.addEventListener("keydown", e => {
    if (e.key === "ArrowUp" && direction !== "DOWN") direction = "UP";
    else if (e.key === "ArrowDown" && direction !== "UP") direction = "DOWN";
    else if (e.key === "ArrowLeft" && direction !== "RIGHT") direction = "LEFT";
    else if (e.key === "ArrowRight" && direction !== "LEFT") direction = "RIGHT";
    else if (e.key === "Enter") restartGame();
    else if (e.key === "Escape") togglePause();
});

function changeDirection(dir) {
    if (dir === "up" && direction !== "DOWN") direction = "UP";
    else if (dir === "down" && direction !== "UP") direction = "DOWN";
    else if (dir === "left" && direction !== "RIGHT") direction = "LEFT";
    else if (dir === "right" && direction !== "LEFT") direction = "RIGHT";
}

function randomFood() {
    return {
        x: Math.floor(Math.random() * (canvas.width / box)) * box,
        y: Math.floor(Math.random() * (canvas.height / box)) * box
    };
}

function draw() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < snake.length; i++) {
        ctx.fillStyle = i === 0 ? "#0f0" : "#0a0";
        ctx.fillRect(snake[i].x, snake[i].y, box, box);
    }

    ctx.fillStyle = "red";
    ctx.fillRect(food.x, food.y, box, box);

    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.fillText("Score: " + score, 10, 20);

    let snakeX = snake[0].x;
    let snakeY = snake[0].y;

    if (direction === "UP") snakeY -= box;
    if (direction === "DOWN") snakeY += box;
    if (direction === "LEFT") snakeX -= box;
    if (direction === "RIGHT") snakeX += box;

    if (snakeX === food.x && snakeY === food.y) {
        score++;
        food = randomFood();
    } else {
        snake.pop();
    }

    let newHead = {x: snakeX, y: snakeY};

    if (
        snakeX < 0 || snakeX >= canvas.width ||
        snakeY < 0 || snakeY >= canvas.height ||
        collision(newHead, snake)
    ) {
        clearInterval(game);
        alert("Game Over! Score: " + score);
        return;
    }

    snake.unshift(newHead);
}

function collision(head, array) {
    for (let part of array) {
        if (head.x === part.x && head.y === part.y) return true;
    }
    return false;
}

function restartGame() {
    clearInterval(game);
    snake = [{x: 9 * box, y: 9 * box}];
    direction = null;
    score = 0;
    isPaused = false;
    game = setInterval(gameLoop, speed);
}

function togglePause() {
    if (isPaused) {
        game = setInterval(gameLoop, speed);
        isPaused = false;
    } else {
        clearInterval(game);
        isPaused = true;
    }
}

function gameLoop() {
    if (!isPaused) draw();
}

restartGame();
</script>

</body>
</html>    let dir = {x: 1, y: 0};               // initial direction -> right
    let nextDir = {x: 1, y: 0};
    let food = null;
    let score = 0;
    let running = true;
    let tickId = null;

    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');

    function startGame(){
      // initialize snake in center
      const startX = Math.floor(COLS/2);
      const startY = Math.floor(ROWS/2);
      snake = [ {x:startX, y:startY}, {x:startX-1, y:startY}, {x:startX-2, y:startY} ];
      dir = {x:1,y:0}; nextDir = {x:1,y:0};
      placeFood();
      score = 0; updateScore();
      running = true; pauseBtn.textContent = 'Pause';
      if(tickId) clearInterval(tickId);
      tickId = setInterval(tick, speed);
      draw();
    }

    function placeFood(){
      while(true){
        const x = Math.floor(Math.random()*COLS);
        const y = Math.floor(Math.random()*ROWS);
        if(!snake.some(p => p.x===x && p.y===y)){
          food = {x,y};
          return;
        }
      }
    }

    function tick(){
      // apply queued direction (avoids 180¬∞ immediate reversal)
      if((nextDir.x !== -dir.x || nextDir.y !== -dir.y) || snake.length===1){
        dir = nextDir;
      }

      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // check wall collision (game over)
      if(head.x < 0 || head.y < 0 || head.x >= COLS || head.y >= ROWS){
        gameOver(); return;
      }
      // check self collision
      if(snake.some(p => p.x===head.x && p.y===head.y)){
        gameOver(); return;
      }

      snake.unshift(head);

      // check food
      if(food && head.x===food.x && head.y===food.y){
        score += 1; updateScore();
        // speed up slightly every 5 points
        if(score % 5 === 0 && speed > 40){
          speed = Math.max(40, speed-6);
          clearInterval(tickId); tickId = setInterval(tick, speed);
        }
        placeFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver(){
      running = false;
      clearInterval(tickId);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '28px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 8);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText('Press Restart to play again', canvas.width/2, canvas.height/2 + 18);
      pauseBtn.textContent = 'Paused';
    }

    function updateScore(){ scoreEl.textContent = score; }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // grid (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for(let x=0;x<=canvas.width;x+=TILE){
        ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,canvas.height); ctx.stroke();
      }
      for(let y=0;y<=canvas.height;y+=TILE){
        ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width,y+0.5); ctx.stroke();
      }

      // draw food
      if(food){
        roundRect(ctx, food.x*TILE+2, food.y*TILE+2, TILE-4, TILE-4, 6);
        ctx.fillStyle = '#10b981'; ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
      }

      // draw snake
      for(let i=0;i<snake.length;i++){
        const p = snake[i];
        const x = p.x*TILE + 1;
        const y = p.y*TILE + 1;
        const w = TILE-2; const h = TILE-2;
        if(i===0){
          // head
          roundRect(ctx,x,y,w,h,6); ctx.fillStyle = '#60a5fa'; ctx.fill();
          ctx.strokeStyle = '#0b1220'; ctx.stroke();
        } else {
          roundRect(ctx,x,y,w,h,4); ctx.fillStyle = '#3b82f6'; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.stroke();
        }
      }
    }

    // helper to draw rounded rect path
    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    // input handling
    window.addEventListener('keydown', e => {
      const k = e.key;
      if(['ArrowUp','w','W'].includes(k)){ nextDir = {x:0,y:-1}; e.preventDefault(); }
      if(['ArrowDown','s','S'].includes(k)){ nextDir = {x:0,y:1}; e.preventDefault(); }
      if(['ArrowLeft','a','A'].includes(k)){ nextDir = {x:-1,y:0}; e.preventDefault(); }
      if(['ArrowRight','d','D'].includes(k)){ nextDir = {x:1,y:0}; e.preventDefault(); }
      if(k === ' '){ togglePause(); }
    });

    // on-screen pad
    document.querySelectorAll('.pad-btn').forEach(b => {
      b.addEventListener('touchstart', e => { const dir = e.currentTarget.dataset.dir; handlePad(dir); e.preventDefault(); });
      b.addEventListener('mousedown', e=>{ handlePad(e.currentTarget.dataset.dir); });
    });
    function handlePad(d){ if(d==='up') nextDir={x:0,y:-1}; if(d==='down') nextDir={x:0,y:1}; if(d==='left') nextDir={x:-1,y:0}; if(d==='right') nextDir={x:1,y:0}; }

    // pause/restart buttons
    pauseBtn.addEventListener('click', togglePause);
    restartBtn.addEventListener('click', () => { speed = 100; startGame(); });

    function togglePause(){
      if(!running){ // resume
        running = true; pauseBtn.textContent = 'Pause';
        tickId = setInterval(tick, speed);
      } else {
        running = false; pauseBtn.textContent = 'Resume';
        clearInterval(tickId);
      }
    }

    // start on load
    startGame();

    // make canvas crisp on HiDPI
    (function adjustHiDPI(){
      const ratio = window.devicePixelRatio || 1;
      if(ratio !== 1){
        const w = canvas.width; const h = canvas.height;
        canvas.width = w * ratio; canvas.height = h * ratio;
        canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        ctx.setTransform(ratio,0,0,ratio,0,0);
      }
    })();
  </script></body>
  </html>
